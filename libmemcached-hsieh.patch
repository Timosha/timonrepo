
# HG changeset patch
# User Eric Lambert <eric.lambert@sun.com>
# Date 1241145108 25200
# Node ID 0fc2011585180b2fc78cdaea965cd46926d62e59
# Parent 7cca934315994b66cbbf4c5cec1651112498e026
Disable hsieh algorithm by default

Per a conversation with Brian earlier this week, there are some licensing
issues with the hsieh hashing algorithm that make it 'desirable' for support
of this algorithm to be a compile time option. This patch turns off support
for hsieh by default but allows it to be used when '--enable-hsieh_hash' is
passed into configure.

--- a/configure.ac	Thu Apr 30 11:27:26 2009 -0700
+++ b/configure.ac	Thu Apr 30 19:31:48 2009 -0700
@@ -64,6 +64,7 @@
 sinclude(config/protocol_binary.m4)
 sinclude(config/memcached.m4)
 sinclude(config/setsockopt.m4)
+sinclude(config/hsieh.m4)
 
 # We only support GCC and Sun's forte at the moment
 if test "$GCC" = "yes"
--- a/docs/memcached_behavior.pod	Thu Apr 30 11:27:26 2009 -0700
+++ b/docs/memcached_behavior.pod	Thu Apr 30 19:31:48 2009 -0700
@@ -84,6 +84,7 @@
 Makes the default hashing algorithm for keys use MD5. The value can be set
 to either MEMCACHED_HASH_DEFAULT, MEMCACHED_HASH_MD5, MEMCACHED_HASH_CRC, MEMCACHED_HASH_FNV1_64, MEMCACHED_HASH_FNV1A_64, MEMCACHED_HASH_FNV1_32, MEMCACHED_HASH_FNV1A_32, MEMCACHED_HASH_JENKINS, MEMCACHED_HASH_HSIEH, and MEMCACHED_HASH_MURMUR. 
 Each hash has it's advantages and it's weaknesses. If you dont know or dont care, just go with the default.
+Support for MEMCACHED_HASH_HSIEH is a compile time option that is disabled by default. To enable support for this hashing algorithm, configure and build libmemcached with the --enable-hash_hsieh. 
 
 =item MEMCACHED_BEHAVIOR_DISTRIBUTION
 
--- a/libmemcached/Makefile.am	Thu Apr 30 11:27:26 2009 -0700
+++ b/libmemcached/Makefile.am	Thu Apr 30 19:31:48 2009 -0700
@@ -29,7 +29,6 @@
 lib_LTLIBRARIES = libmemcached.la
 
 libmemcached_la_SOURCES = crc.c \
-			  hsieh_hash.c \
 			  memcached.c \
 			  memcached_auto.c \
 			  memcached_analyze.c \
@@ -62,6 +61,10 @@
 			  murmur_hash.c \
 			  jenkins_hash.c
 
+if INCLUDE_HSIEH_SRC
+libmemcached_la_SOURCES += hsieh_hash.c
+endif
+
 if BUILD_BYTEORDER
 libmemcached_la_SOURCES += byteorder.c
 endif
--- a/libmemcached/common.h	Thu Apr 30 11:27:26 2009 -0700
+++ b/libmemcached/common.h	Thu Apr 30 19:31:48 2009 -0700
@@ -84,7 +84,9 @@
 void md5_signature(const unsigned char *key, unsigned int length, unsigned char *result);
 uint32_t hash_crc32(const char *data,
                     size_t data_len);
+#ifdef HAVE_HSIEH_HASH
 uint32_t hsieh_hash(const char *key, size_t key_length);
+#endif
 uint32_t murmur_hash(const char *key, size_t key_length);
 uint32_t jenkins_hash(const void *key, size_t length, uint32_t initval);
 
--- a/libmemcached/memcached_behavior.c	Thu Apr 30 11:27:26 2009 -0700
+++ b/libmemcached/memcached_behavior.c	Thu Apr 30 19:31:48 2009 -0700
@@ -100,6 +100,10 @@
       break;
     }
   case MEMCACHED_BEHAVIOR_HASH:
+#ifndef HAVE_HSIEH_HASH
+    if ((memcached_hash)(data) == MEMCACHED_HASH_HSIEH)
+      return MEMCACHED_FAILURE;
+#endif
     ptr->hash= (memcached_hash)(data);
     break;
   case MEMCACHED_BEHAVIOR_KETAMA_HASH:
--- a/libmemcached/memcached_hash.c	Thu Apr 30 11:27:26 2009 -0700
+++ b/libmemcached/memcached_hash.c	Thu Apr 30 19:31:48 2009 -0700
@@ -74,11 +74,13 @@
       }
     }
     break;
+#ifdef HAVE_HSIEH_HASH
     case MEMCACHED_HASH_HSIEH:
     {
       hash= hsieh_hash(key, key_length);
       break;
     }
+#endif
     case MEMCACHED_HASH_MURMUR:
     {
       hash= murmur_hash(key, key_length);
--- a/tests/function.c	Thu Apr 30 11:27:26 2009 -0700
+++ b/tests/function.c	Thu Apr 30 19:31:48 2009 -0700
@@ -2856,9 +2856,12 @@
 
 static memcached_return  pre_hsieh(memcached_st *memc)
 {
+#ifdef HAVE_HSIEH_HASH
   memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_HASH, (uint64_t)MEMCACHED_HASH_HSIEH);
-
   return MEMCACHED_SUCCESS;
+#else
+  return MEMCACHED_FAILURE;
+#endif
 }
 
 static memcached_return  pre_hash_fnv1_64(memcached_st *memc)
@@ -3069,7 +3072,8 @@
   memcached_server_distribution value= MEMCACHED_DISTRIBUTION_CONSISTENT;
   memcached_hash hash;
   memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_DISTRIBUTION, value);
-  pre_hsieh(memc);
+  if (pre_hsieh(memc) != MEMCACHED_SUCCESS)
+    return MEMCACHED_FAILURE;
 
   value= (memcached_server_distribution)memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_DISTRIBUTION);
   assert(value == MEMCACHED_DISTRIBUTION_CONSISTENT);
@@ -3624,6 +3628,18 @@
   return TEST_SUCCESS;
 }
 
+test_return hsieh_avaibility_test (memcached_st *memc)
+{
+  memcached_return expected_rc= MEMCACHED_FAILURE;
+#ifdef HAVE_HSIEH_HASH
+  expected_rc= MEMCACHED_SUCCESS;
+#endif
+  memcached_return rc= memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_HASH,
+                                            (uint64_t)MEMCACHED_HASH_HSIEH);
+  assert(rc == expected_rc);
+  return TEST_SUCCESS;
+}
+
 test_st udp_setup_server_tests[] ={
   {"set_udp_behavior_test", 0, set_udp_behavior_test},
   {"add_tcp_server_udp_client_test", 0, add_tcp_server_udp_client_test},
@@ -3795,7 +3811,13 @@
   {0, 0, 0}
 };
 
+test_st hsieh_availability[] ={
+  {"hsieh_avaibility_test",0,hsieh_avaibility_test},
+  {0, 0, 0}
+};
+
 collection_st collection[] ={
+  {"hsieh_availability",0,0,hsieh_availability},
   {"udp_setup", init_udp, 0, udp_setup_server_tests},
   {"udp_io", init_udp, 0, upd_io_tests},
   {"udp_binary_io", binary_init_udp, 0, upd_io_tests},
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/config/hsieh.m4	Thu Apr 30 19:31:48 2009 -0700
@@ -0,0 +1,22 @@
+dnl ---------------------------------------------------------------------------
+dnl Macro: HSIEH_HASH
+dnl ---------------------------------------------------------------------------
+AC_ARG_ENABLE(hsieh_hash,
+    [  --enable-hsieh_hash     build with support for hsieh hashing.],
+    [
+      if test "x$enableval" != "xno"; then
+          ENABLE_HSIEH="true"
+          AC_DEFINE([HAVE_HSIEH_HASH], [1], [Enables hsieh hashing support])
+      else
+          ENABLE_HSIEH="false"
+      fi
+    ],
+    [
+      ENABLE_HSIEH="false"
+    ]
+)
+
+AM_CONDITIONAL([INCLUDE_HSIEH_SRC], [test "x$ENABLE_HSIEH" = "xtrue"])
+dnl ---------------------------------------------------------------------------
+dnl End Macro: HSIEH_HASH
+dnl ---------------------------------------------------------------------------

