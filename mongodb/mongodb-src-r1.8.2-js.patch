diff -urp mongodb-src-r1.8.2.orig/SConstruct mongodb-src-r1.8.2/SConstruct
--- mongodb-src-r1.8.2.orig/SConstruct	2011-07-01 11:55:58.350694155 -0400
+++ mongodb-src-r1.8.2/SConstruct	2011-07-01 11:56:17.108504474 -0400
@@ -668,10 +668,9 @@ if nix:
     if has_option( "distcc" ):
         env["CXX"] = "distcc " + env["CXX"]
         
-    env.Append( CPPFLAGS="-fPIC -fno-strict-aliasing -ggdb -pthread -Wall -Wsign-compare -Wno-unknown-pragmas -Winvalid-pch" )
+    env.Append( CPPFLAGS="-fPIC -fno-strict-aliasing -ggdb -pthread -DBOOST_FILESYSTEM_VERSION=2 -Wsign-compare -Wno-unknown-pragmas -Winvalid-pch" )
     # env.Append( " -Wconversion" ) TODO: this doesn't really work yet
     if linux:
-        env.Append( CPPFLAGS=" -Werror " )
         env.Append( CPPFLAGS=" -fno-builtin-memcmp " ) # glibc's memcmp is faster than gcc's
     env.Append( CXXFLAGS=" -Wnon-virtual-dtor " )
     env.Append( LINKFLAGS=" -fPIC -pthread -rdynamic" )
@@ -688,7 +687,7 @@ if nix:
         env.Append( CPPFLAGS=" -O0 -fstack-protector " );
         env['ENV']['GLIBCXX_FORCE_NEW'] = 1; # play nice with valgrind
     else:
-        env.Append( CPPFLAGS=" -O3" )
+        env.Append( CPPFLAGS=" -O3 -fpermissive" )
         #env.Append( CPPFLAGS=" -fprofile-generate" )
         #env.Append( LINKFLAGS=" -fprofile-generate" )
         # then:
diff -urp mongodb-src-r1.8.2.orig/scripting/engine_spidermonkey.cpp mongodb-src-r1.8.2/scripting/engine_spidermonkey.cpp
--- mongodb-src-r1.8.2.orig/scripting/engine_spidermonkey.cpp	2011-06-15 09:43:13.000000000 -0400
+++ mongodb-src-r1.8.2/scripting/engine_spidermonkey.cpp	2011-07-01 12:00:32.489692570 -0400
@@ -192,35 +192,18 @@ namespace mongo {
         }
 
         string toString( JSString * so ) {
-            jschar * s = JS_GetStringChars( so );
-            size_t srclen = JS_GetStringLength( so );
-            if( srclen == 0 )
+            char * s = (char *)JS_EncodeString(_context, so );
+            size_t srclen = strlen( s );
+            if( srclen == 0 ) {
+                JS_free(_context, s);
                 return "";
-
-            size_t len = srclen * 6; // we only need *3, but see note on len below
-            char * dst = (char*)malloc( len );
-
-            len /= 2;
-            // doc re weird JS_EncodeCharacters api claims len expected in 16bit
-            // units, but experiments suggest 8bit units expected.  We allocate
-            // enough memory that either will work.
-
-            if ( !JS_EncodeCharacters( _context , s , srclen , dst , &len) ) {
-                StringBuilder temp;
-                temp << "Not proper UTF-16: ";
-                for ( size_t i=0; i<srclen; i++ ) {
-                    if ( i > 0 )
-                        temp << ",";
-                    temp << s[i];
-                }
-                uasserted( 13498 , temp.str() );
             }
 
-            string ss( dst , len );
-            free( dst );
+            string ss( s, srclen );
+            JS_free(_context, s);
             if ( !JS_CStringsAreUTF8() )
                 for( string::const_iterator i = ss.begin(); i != ss.end(); ++i )
-                    uassert( 10213 ,  "non ascii character detected", (unsigned char)(*i) <= 127 );
+                  uassert( 10213 ,  "non ascii character detected", (unsigned char)(*i) <= 127 );
             return ss;
         }
 
@@ -419,8 +402,6 @@ namespace mongo {
             return true;
         }
 
-        void addRoot( JSFunction * f , const char * name );
-
         JSFunction * compileFunction( const char * code, JSObject * assoc = 0 ) {
             const char * gcName = "unknown";
             JSFunction * f = _compileFunction( code , assoc , gcName );
@@ -630,7 +611,11 @@ namespace mongo {
                     flags++;
                 }
 
-                JSObject * r = JS_NewRegExpObject( _context , (char*)e.regex() , strlen( e.regex() ) , flagNumber );
+                JSObject * r = JS_NewRegExpObject(_context,
+                                                  JS_GetGlobalObject(_context),
+                                                  (char *)e.regex(),
+                                                  strlen(e.regex()),
+                                                  flagNumber);
                 assert( r );
                 return OBJECT_TO_JSVAL( r );
             }
@@ -651,7 +636,7 @@ namespace mongo {
                 return OBJECT_TO_JSVAL( JS_GetFunctionObject( func ) );
             }
             case Date:
-                return OBJECT_TO_JSVAL( js_NewDateObjectMsec( _context , (jsdouble) e.date().millis ) );
+                return OBJECT_TO_JSVAL( JS_NewDateObjectMsec( _context , (jsdouble) e.date().millis ) );
 
             case MinKey:
                 return OBJECT_TO_JSVAL( JS_NewObject( _context , &minkey_class , 0 , 0 ) );
@@ -818,7 +803,7 @@ namespace mongo {
         return JS_FALSE;
     }
 
-    JSBool noaccess( JSContext *cx, JSObject *obj, jsval idval, jsval *vp) {
+    JSBool noaccess( JSContext *cx, JSObject *obj, jsid id, jsval *vp) {
         BSONHolder * holder = GETHOLDER( cx , obj );
         if ( ! holder ) {
             // in init code still
@@ -837,7 +822,7 @@ namespace mongo {
         JSCLASS_NO_OPTIONAL_MEMBERS
     };
 
-    JSBool bson_cons( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool bson_cons( JSContext *cx, uintN argc, jsval *vp ) {
         cerr << "bson_cons : shouldn't be here!" << endl;
         JS_ReportError( cx , "can't construct bson object" );
         return JS_FALSE;
@@ -847,7 +832,7 @@ namespace mongo {
         { 0 }
     };
 
-    JSBool bson_add_prop( JSContext *cx, JSObject *obj, jsval idval, jsval *vp) {
+    JSBool bson_add_prop( JSContext *cx, JSObject *obj, jsid id, jsval *vp) {
         BSONHolder * holder = GETHOLDER( cx , obj );
         if ( ! holder ) {
             // static init
@@ -855,7 +840,7 @@ namespace mongo {
         }
         if ( ! holder->_inResolve ) {
             Convertor c(cx);
-            string name = c.toString( idval );
+            string name = c.toString( JSID_TO_STRING(id) );
             if ( holder->_obj[name].eoo() ) {
                 holder->_extra.push_back( name );
             }
@@ -865,7 +850,7 @@ namespace mongo {
     }
 
 
-    JSBool mark_modified( JSContext *cx, JSObject *obj, jsval idval, jsval *vp) {
+    JSBool mark_modified( JSContext *cx, JSObject *obj, jsid id, jsval *vp) {
         Convertor c(cx);
         BSONHolder * holder = GETHOLDER( cx , obj );
         if ( !holder ) // needed when we're messing with DBRef.prototype
@@ -873,17 +858,17 @@ namespace mongo {
         if ( holder->_inResolve )
             return JS_TRUE;
         holder->_modified = true;
-        holder->_removed.erase( c.toString( idval ) );
+        holder->_removed.erase( c.toString( JSID_TO_STRING(id) ) );
         return JS_TRUE;
     }
 
-    JSBool mark_modified_remove( JSContext *cx, JSObject *obj, jsval idval, jsval *vp) {
+    JSBool mark_modified_remove( JSContext *cx, JSObject *obj, jsid id, jsval *vp) {
         Convertor c(cx);
         BSONHolder * holder = GETHOLDER( cx , obj );
         if ( holder->_inResolve )
             return JS_TRUE;
         holder->_modified = true;
-        holder->_removed.insert( c.toString( idval ) );
+        holder->_removed.insert( c.toString( JSID_TO_STRING(id) ) );
         return JS_TRUE;
     }
 
@@ -903,9 +888,10 @@ namespace mongo {
 
     // --- global helpers ---
 
-    JSBool native_print( JSContext * cx , JSObject * obj , uintN argc, jsval *argv, jsval *rval ) {
+    JSBool native_print( JSContext * cx , uintN argc, jsval *vp) {
         stringstream ss;
         Convertor c( cx );
+        jsval *argv = JS_ARGV(cx, vp);
         for ( uintN i=0; i<argc; i++ ) {
             if ( i > 0 )
                 ss << " ";
@@ -916,14 +902,17 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool native_helper( JSContext *cx , JSObject *obj , uintN argc, jsval *argv , jsval *rval ) {
+    JSBool native_helper( JSContext * cx , uintN argc, jsval *vp ) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
-
+    
         NativeFunction func = (NativeFunction)((long long)c.getNumber( obj , "x" ) );
         assert( func );
 
         BSONObj a;
         if ( argc > 0 ) {
+            jsval *argv = JS_ARGV(cx, vp);
             BSONObjBuilder args;
             for ( uintN i=0; i<argc; i++ ) {
                 c.append( args , args.numStr( i ) , argv[i] );
@@ -942,35 +931,39 @@ namespace mongo {
         }
 
         if ( out.isEmpty() ) {
-            *rval = JSVAL_VOID;
+            JS_SET_RVAL(cx, vp, JSVAL_VOID);
         }
         else {
-            *rval = c.toval( out.firstElement() );
+            JS_SET_RVAL(cx, vp, c.toval( out.firstElement() ));
         }
 
         return JS_TRUE;
     }
 
-    JSBool native_load( JSContext *cx , JSObject *obj , uintN argc, jsval *argv , jsval *rval );
+    JSBool native_load( JSContext * cx , uintN argc, jsval *vp );
 
-    JSBool native_gc( JSContext *cx , JSObject *obj , uintN argc, jsval *argv , jsval *rval ) {
+    JSBool native_gc(JSContext * cx , uintN argc, jsval *vp )
+    {
         JS_GC( cx );
         return JS_TRUE;
     }
 
     JSFunctionSpec globalHelpers[] = {
-        { "print" , &native_print , 0 , 0 , 0 } ,
-        { "nativeHelper" , &native_helper , 1 , 0 , 0 } ,
-        { "load" , &native_load , 1 , 0 , 0 } ,
-        { "gc" , &native_gc , 1 , 0 , 0 } ,
-        { 0 , 0 , 0 , 0 , 0 }
+        { "print" , &native_print , 0 , 0 } ,
+        { "nativeHelper" , &native_helper , 1 , 0 } ,
+        { "load" , &native_load , 1 , 0 } ,
+        { "gc" , &native_gc , 1 , 0 } ,
+        { 0 , 0 , 0 , 0 }
     };
 
     // ----END global helpers ----
 
     // Object helpers
 
-    JSBool bson_get_size(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool bson_get_size(JSContext * cx , uintN argc, jsval *vp )
+    {
+        jsval *argv = JS_ARGV(cx, vp);
+
         if ( argc != 1 || !JSVAL_IS_OBJECT( argv[ 0 ] ) ) {
             JS_ReportError( cx , "bsonsize requires one valid object" );
             return JS_FALSE;
@@ -979,7 +972,7 @@ namespace mongo {
         Convertor c(cx);
 
         if ( argv[0] == JSVAL_VOID || argv[0] == JSVAL_NULL ) {
-            *rval = c.toval( 0.0 );
+            JS_SET_RVAL(cx, vp, c.toval( 0.0 ));
             return JS_TRUE;
         }
 
@@ -999,18 +992,18 @@ namespace mongo {
             size = temp.objsize();
         }
 
-        *rval = c.toval( size );
+        JS_SET_RVAL(cx, vp, c.toval( size ));
         return JS_TRUE;
     }
 
     JSFunctionSpec objectHelpers[] = {
-        { "bsonsize" , &bson_get_size , 1 , 0 , 0 } ,
-        { 0 , 0 , 0 , 0 , 0 }
+        { "bsonsize" , &bson_get_size , 1 , 0 } ,
+        { 0 , 0 , 0 , 0 }
     };
 
     // end Object helpers
 
-    JSBool resolveBSONField( JSContext *cx, JSObject *obj, jsval id, uintN flags, JSObject **objp ) {
+    JSBool resolveBSONField( JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp ) {
         assert( JS_EnterLocalRootScope( cx ) );
         Convertor c( cx );
 
@@ -1023,7 +1016,7 @@ namespace mongo {
         }
         holder->check();
 
-        string s = c.toString( id );
+        string s = c.toString( JSID_TO_STRING(id) );
 
         BSONElement e = holder->_obj[ s.c_str() ];
 
@@ -1069,9 +1062,7 @@ namespace mongo {
     public:
 
         SMEngine() {
-#ifdef SM18
             JS_SetCStringsAreUTF8();
-#endif
 
             _runtime = JS_NewRuntime(8L * 1024L * 1024L);
             uassert( 10221 ,  "JS_NewRuntime failed" , _runtime );
@@ -1139,7 +1130,7 @@ namespace mongo {
             //JS_SetVersion( _context , JSVERSION_LATEST); TODO
             JS_SetErrorReporter( _context , errorReporter );
 
-            _global = JS_NewObject( _context , &global_class, NULL, NULL);
+            _global = JS_NewCompartmentAndGlobalObject( _context , &global_class, NULL);
             massert( 10432 ,  "JS_NewObject failed for global" , _global );
             JS_SetGlobalObject( _context , _global );
             massert( 10433 ,  "js init failed" , JS_InitStandardClasses( _context , _global ) );
@@ -1158,14 +1149,8 @@ namespace mongo {
         ~SMScope() {
             smlock;
             uassert( 10223 ,  "deleted SMScope twice?" , _convertor );
-
-            for ( list<void*>::iterator i=_roots.begin(); i != _roots.end(); i++ ) {
-                JS_RemoveRoot( _context , *i );
-            }
-            _roots.clear();
-
             if ( _this ) {
-                JS_RemoveRoot( _context , &_this );
+                JS_RemoveObjectRoot( _context , &_this );
                 _this = 0;
             }
 
@@ -1187,18 +1172,13 @@ namespace mongo {
             assert( _convertor );
             return;
             if ( _this ) {
-                JS_RemoveRoot( _context , &_this );
+                JS_RemoveObjectRoot( _context , &_this );
                 _this = 0;
             }
             currentScope.reset( this );
             _error = "";
         }
 
-        void addRoot( void * root , const char * name ) {
-            JS_AddNamedRoot( _context , root , name );
-            _roots.push_back( root );
-        }
-
         void init( const BSONObj * data ) {
             smlock;
             if ( ! data )
@@ -1336,13 +1316,13 @@ namespace mongo {
         void setThis( const BSONObj * obj ) {
             smlock;
             if ( _this ) {
-                JS_RemoveRoot( _context , &_this );
+                JS_RemoveObjectRoot( _context , &_this );
                 _this = 0;
             }
 
             if ( obj ) {
                 _this = _convertor->toJSObject( obj );
-                JS_AddNamedRoot( _context , &_this , "scope this" );
+                JS_AddObjectRoot( _context , &_this );
             }
         }
 
@@ -1391,7 +1371,7 @@ namespace mongo {
 
         }
 
-        static JSBool interrupt( JSContext *cx, JSScript *script ) {
+        static JSBool interrupt( JSContext *cx, JSObject *script ) {
             return _interrupt( cx );
         }
 
@@ -1402,21 +1382,13 @@ namespace mongo {
                 spec->start = boost::posix_time::microsec_clock::local_time();
                 spec->count = 0;
                 JS_SetContextPrivate( _context, (void*)spec );
-#if defined(SM181) && !defined(XULRUNNER190)
                 JS_SetOperationCallback( _context, _interrupt );
-#else
-                JS_SetBranchCallback( _context, interrupt );
-#endif
             }
         }
 
         void uninstallInterrupt( int timeoutMs ) {
             if ( timeoutMs != 0 || ScriptEngine::haveCheckInterruptCallback() ) {
-#if defined(SM181) && !defined(XULRUNNER190)
                 JS_SetOperationCallback( _context , 0 );
-#else
-                JS_SetBranchCallback( _context, 0 );
-#endif
                 delete (TimeoutSpec *)JS_GetContextPrivate( _context );
                 JS_SetContextPrivate( _context, 0 );
             }
@@ -1579,11 +1551,12 @@ namespace mongo {
         }
     }
 
-    JSBool native_load( JSContext *cx , JSObject *obj , uintN argc, jsval *argv , jsval *rval ) {
+    JSBool native_load( JSContext * cx , uintN argc, jsval *vp ) {
         Convertor c(cx);
 
         Scope * s = currentScope.get();
 
+        jsval *argv = JS_ARGV(cx, vp);
         for ( uintN i=0; i<argc; i++ ) {
             string filename = c.toString( argv[i] );
             //cout << "load [" << filename << "]" << endl;
@@ -1633,18 +1606,6 @@ namespace mongo {
         return new SMScope();
     }
 
-    void Convertor::addRoot( JSFunction * f , const char * name ) {
-        if ( ! f )
-            return;
-
-        SMScope * scope = currentScope.get();
-        uassert( 10229 ,  "need a scope" , scope );
-
-        JSObject * o = JS_GetFunctionObject( f );
-        assert( o );
-        scope->addRoot( &o , name );
-    }
-
 }
 
 #include "sm_db.cpp"
diff -urp mongodb-src-r1.8.2.orig/scripting/engine_spidermonkey.h mongodb-src-r1.8.2/scripting/engine_spidermonkey.h
--- mongodb-src-r1.8.2.orig/scripting/engine_spidermonkey.h	2011-06-15 09:43:13.000000000 -0400
+++ mongodb-src-r1.8.2/scripting/engine_spidermonkey.h	2011-07-01 12:00:47.958886768 -0400
@@ -42,9 +42,6 @@
 #endif
 
 #include "jsapi.h"
-#include "jsobj.h"
-#include "jsdate.h"
-#include "jsregexp.h"
 
 #else
 
@@ -104,7 +101,7 @@ namespace mongo {
     extern boost::thread_specific_ptr<SMScope> currentScope;
 
     // bson
-    JSBool resolveBSONField( JSContext *cx, JSObject *obj, jsval id, uintN flags, JSObject **objp );
+    JSBool resolveBSONField( JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp );
 
 
     // mongo
diff -urp mongodb-src-r1.8.2.orig/scripting/sm_db.cpp mongodb-src-r1.8.2/scripting/sm_db.cpp
--- mongodb-src-r1.8.2.orig/scripting/sm_db.cpp	2011-06-15 09:43:13.000000000 -0400
+++ mongodb-src-r1.8.2/scripting/sm_db.cpp	2011-07-01 12:03:03.220174591 -0400
@@ -22,6 +22,9 @@
 #include "../util/text.h"
 #include "../util/hex.h"
 
+extern JS_FRIEND_API(jsdouble)
+js_DateGetMsecSinceEpoch(JSContext *cx, JSObject *obj);
+
 #if( BOOST_VERSION >= 104200 )
 //#include <boost/uuid/uuid.hpp>
 #define HAVE_UUID 1
@@ -79,7 +82,12 @@ namespace mongo {
         return holder->get();
     }
 
-    JSBool internal_cursor_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    extern JSClass internal_cursor_class;
+  
+    JSBool internal_cursor_constructor( JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &internal_cursor_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         uassert( 10236 ,  "no args to internal_cursor_constructor" , argc == 0 );
         assert( JS_SetPrivate( cx , obj , 0 ) ); // just for safety
         return JS_TRUE;
@@ -93,10 +101,13 @@ namespace mongo {
         }
     }
 
-    JSBool internal_cursor_hasNext(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool internal_cursor_hasNext(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
+  
         DBClientCursor *cursor = getCursor( cx, obj );
         try {
-            *rval = cursor->more() ? JSVAL_TRUE : JSVAL_FALSE;
+            JS_SET_RVAL(cx, vp, cursor->more() ? JSVAL_TRUE : JSVAL_FALSE);
         }
         catch ( std::exception& e ) {
             JS_ReportError( cx , e.what() );
@@ -105,14 +116,19 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool internal_cursor_objsLeftInBatch(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool internal_cursor_objsLeftInBatch(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
+  
         DBClientCursor *cursor = getCursor( cx, obj );
         Convertor c(cx);
-        *rval = c.toval((double) cursor->objsLeftInBatch() );
+        JS_SET_RVAL(cx, vp, c.toval((double) cursor->objsLeftInBatch() ));
         return JS_TRUE;
     }
 
-    JSBool internal_cursor_next(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool internal_cursor_next(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         DBClientCursor *cursor = getCursor( cx, obj );
 
         BSONObj n;
@@ -131,14 +147,14 @@ namespace mongo {
         }
 
         Convertor c(cx);
-        *rval = c.toval( &n );
+        JS_SET_RVAL(cx, vp, c.toval( &n ));
         return JS_TRUE;
     }
 
     JSFunctionSpec internal_cursor_functions[] = {
-        { "hasNext" , internal_cursor_hasNext , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "objsLeftInBatch" , internal_cursor_objsLeftInBatch , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "next" , internal_cursor_next , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
+        { "hasNext" , internal_cursor_hasNext , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "objsLeftInBatch" , internal_cursor_objsLeftInBatch , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "next" , internal_cursor_next , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
         { 0 }
     };
 
@@ -152,12 +168,17 @@ namespace mongo {
 
     // ------ mongo stuff ------
 
-    JSBool mongo_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool mongo_constructor( JSContext *cx, uintN argc, jsval *vp ) {
         uassert( 10237 ,  "mongo_constructor not implemented yet" , 0 );
         throw -1;
     }
 
-    JSBool mongo_local_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    extern JSClass mongo_class;
+  
+    JSBool mongo_local_constructor(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_NewObject(cx, &mongo_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         Convertor c( cx );
 
         shared_ptr< DBClientWithCommands > client( createDirectClient() );
@@ -169,7 +190,12 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool mongo_external_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool mongo_external_constructor(JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &mongo_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
+        jsval *argv = JS_ARGV(cx, vp);
+		
         Convertor c( cx );
 
         smuassert( cx ,  "0 or 1 args to Mongo" , argc <= 1 );
@@ -197,8 +223,8 @@ namespace mongo {
         assert( JS_SetPrivate( cx , obj , (void*)( new shared_ptr< DBClientWithCommands >( conn ) ) ) );
         jsval host_val = c.toval( host.c_str() );
         assert( JS_SetProperty( cx , obj , "host" , &host_val ) );
-        return JS_TRUE;
 
+        return JS_TRUE;
     }
 
     DBClientWithCommands *getConnection( JSContext *cx, JSObject *obj ) {
@@ -222,7 +248,12 @@ namespace mongo {
         JSCLASS_NO_OPTIONAL_MEMBERS
     };
 
-    JSBool mongo_find(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool mongo_find(JSContext *cx, uintN argc, jsval *vp)
+    {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
+        jsval *argv = JS_ARGV(cx, vp);
+
         smuassert( cx , "mongo_find needs 7 args" , argc == 7 );
         shared_ptr< DBClientWithCommands > * connHolder = (shared_ptr< DBClientWithCommands >*)JS_GetPrivate( cx , obj );
         smuassert( cx ,  "no connection!" , connHolder && connHolder->get() );
@@ -252,7 +283,7 @@ namespace mongo {
             JSObject * mycursor = JS_NewObject( cx , &internal_cursor_class , 0 , 0 );
             CHECKNEWOBJECT( mycursor, cx, "internal_cursor_class" );
             assert( JS_SetPrivate( cx , mycursor , new CursorHolder( cursor, *connHolder ) ) );
-            *rval = OBJECT_TO_JSVAL( mycursor );
+            JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL( mycursor ));
             return JS_TRUE;
         }
         catch ( ... ) {
@@ -261,7 +292,12 @@ namespace mongo {
         }
     }
 
-    JSBool mongo_update(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool mongo_update(JSContext *cx, uintN argc, jsval *vp)
+    {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
+        jsval *argv = JS_ARGV(cx, vp);
+
         smuassert( cx ,  "mongo_find needs at elast 3 args" , argc >= 3 );
         smuassert( cx ,  "2nd param to update has to be an object" , JSVAL_IS_OBJECT( argv[1] ) );
         smuassert( cx ,  "3rd param to update has to be an object" , JSVAL_IS_OBJECT( argv[2] ) );
@@ -290,7 +326,12 @@ namespace mongo {
         }
     }
 
-    JSBool mongo_insert(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool mongo_insert(JSContext *cx, uintN argc, jsval *vp)
+    {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
+        jsval *argv = JS_ARGV(cx, vp);
+
         smuassert( cx ,  "mongo_insert needs 2 args" , argc == 2 );
         smuassert( cx ,  "2nd param to insert has to be an object" , JSVAL_IS_OBJECT( argv[1] ) );
 
@@ -325,7 +366,12 @@ namespace mongo {
         }
     }
 
-    JSBool mongo_remove(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool mongo_remove(JSContext *cx, uintN argc, jsval *vp)
+    {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
+        jsval *argv = JS_ARGV(cx, vp);
+
         smuassert( cx ,  "mongo_remove needs 2 or 3 arguments" , argc == 2 || argc == 3 );
         smuassert( cx ,  "2nd param to insert has to be an object" , JSVAL_IS_OBJECT( argv[1] ) );
 
@@ -361,16 +407,23 @@ namespace mongo {
     }
 
     JSFunctionSpec mongo_functions[] = {
-        { "find" , mongo_find , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "update" , mongo_update , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "insert" , mongo_insert , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "remove" , mongo_remove , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
+        { "find" , mongo_find , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "update" , mongo_update , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "insert" , mongo_insert , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "remove" , mongo_remove , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
         { 0 }
     };
 
     // -------------  db_collection -------------
 
-    JSBool db_collection_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    extern JSClass db_collection_class;
+  
+    JSBool db_collection_constructor(JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &db_collection_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
+        jsval *argv = JS_ARGV(cx, vp);
+    
         smuassert( cx ,  "db_collection_constructor wrong args" , argc == 4 );
         assert( JS_SetProperty( cx , obj , "_mongo" , &(argv[0]) ) );
         assert( JS_SetProperty( cx , obj , "_db" , &(argv[1]) ) );
@@ -386,12 +439,12 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool db_collection_resolve( JSContext *cx, JSObject *obj, jsval id, uintN flags, JSObject **objp ) {
+    JSBool db_collection_resolve( JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp ) {
         if ( flags & JSRESOLVE_ASSIGNING )
             return JS_TRUE;
 
         Convertor c( cx );
-        string collname = c.toString( id );
+        string collname = c.toString( JSID_TO_STRING(id) );
 
         if ( isSpecialName( collname ) )
             return JS_TRUE;
@@ -453,8 +506,14 @@ namespace mongo {
 
     // --------------  DB ---------------
 
+    extern JSClass db_class;
 
-    JSBool db_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool db_constructor( JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &db_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
+        jsval *argv = JS_ARGV(cx, vp);
+    
         smuassert( cx,  "wrong number of arguments to DB" , argc == 2 );
         assert( JS_SetProperty( cx , obj , "_mongo" , &(argv[0]) ) );
         assert( JS_SetProperty( cx , obj , "_name" , &(argv[1]) ) );
@@ -462,7 +521,7 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool db_resolve( JSContext *cx, JSObject *obj, jsval id, uintN flags, JSObject **objp ) {
+    JSBool db_resolve( JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp ) {
         if ( flags & JSRESOLVE_ASSIGNING )
             return JS_TRUE;
 
@@ -471,7 +530,7 @@ namespace mongo {
         if ( obj == c.getGlobalPrototype( "DB" ) )
             return JS_TRUE;
 
-        string collname = c.toString( id );
+        string collname = c.toString( JSID_TO_STRING(id) );
 
         if ( isSpecialName( collname ) )
             return JS_TRUE;
@@ -499,7 +558,13 @@ namespace mongo {
 
     // -------------- object id -------------
 
-    JSBool object_id_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool object_id_constructor( JSContext *cx, uintN argc, jsval *vp) 
+    {
+        JSObject *obj = JS_NewObject(cx, &object_id_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
+        jsval *argv = JS_ARGV(cx, vp);
+    
         Convertor c( cx );
 
         OID oid;
@@ -524,7 +589,7 @@ namespace mongo {
         if ( ! JS_InstanceOf( cx , obj , &object_id_class , 0 ) ) {
             obj = JS_NewObject( cx , &object_id_class , 0 , 0 );
             CHECKNEWOBJECT( obj, cx, "object_id_constructor" );
-            *rval = OBJECT_TO_JSVAL( obj );
+            JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL( obj ));
         }
 
         jsval v = c.toval( oid.str().c_str() );
@@ -540,22 +605,31 @@ namespace mongo {
         JSCLASS_NO_OPTIONAL_MEMBERS
     };
 
-    JSBool object_id_tostring(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool object_id_tostring(JSContext *cx, uintN argc, jsval *vp)
+    {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
-        return (JSBool) (*rval = c.getProperty( obj , "str" ));
+        JS_SET_RVAL(cx, vp, c.getProperty( obj , "str" ));
+        return (JSBool) JS_RVAL(cx, vp);
     }
 
     JSFunctionSpec object_id_functions[] = {
-        { "toString" , object_id_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
+        { "toString" , object_id_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
         { 0 }
     };
 
     // dbpointer
 
-    JSBool dbpointer_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool dbpointer_constructor( JSContext *cx, uintN argc, jsval *vp )
+    {
+        JSObject *obj = JS_NewObject(cx, &dbpointer_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         Convertor c( cx );
 
         if ( argc == 2 ) {
+            jsval *argv = JS_ARGV(cx, vp);
 
             if ( ! JSVAL_IS_OID( argv[1] ) ) {
                 JS_ReportError( cx , "2nd arg to DBPointer needs to be oid" );
@@ -584,10 +658,14 @@ namespace mongo {
     };
 
 
-    JSBool dbref_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool dbref_constructor( JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &dbref_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         Convertor c( cx );
 
         if ( argc == 2 ) {
+            jsval *argv = JS_ARGV(cx, vp);
             JSObject * o = JS_NewObject( cx , NULL , NULL, NULL );
             CHECKNEWOBJECT( o, cx, "dbref_constructor" );
             assert( JS_SetProperty( cx, o , "$ref" , &argv[ 0 ] ) );
@@ -607,7 +685,12 @@ namespace mongo {
 
     // UUID **************************
 
-    JSBool uuid_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    extern JSClass uuid_class;
+  
+    JSBool uuid_constructor( JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &uuid_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         Convertor c( cx );
 
         if( argc == 0 ) {
@@ -619,6 +702,7 @@ namespace mongo {
             return JS_FALSE;
         }
         else if ( argc == 1 ) {
+            jsval *argv = JS_ARGV(cx, vp);
 
             string encoded = c.toString( argv[ 0 ] );
             if( encoded.size() != 32 ) {
@@ -643,7 +727,9 @@ namespace mongo {
         }
     }
 
-    JSBool uuid_tostring(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool uuid_tostring(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);        
+        assert(obj);
         Convertor c(cx);
         void *holder = JS_GetPrivate( cx, obj );
         assert( holder );
@@ -652,7 +738,8 @@ namespace mongo {
         ss << "UUID(\"" << toHex(data, 16);
         ss << "\")";
         string ret = ss.str();
-        return *rval = c.toval( ret.c_str() );
+        JS_SET_RVAL(cx, vp, c.toval( ret.c_str() ));
+        return JS_RVAL(cx, vp);
     }
 
     void uuid_finalize( JSContext * cx , JSObject * obj ) {
@@ -672,16 +759,20 @@ namespace mongo {
     };
 
     JSFunctionSpec uuid_functions[] = {
-        { "toString" , uuid_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
+        { "toString" , uuid_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
         { 0 }
     };
 
     // BinData **************************
 
-    JSBool bindata_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool bindata_constructor(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_NewObject(cx, &bindata_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         Convertor c( cx );
 
         if ( argc == 2 ) {
+            jsval *argv = JS_ARGV(cx, vp);
 
             int type = (int)c.toNumber( argv[ 0 ] );
             if( type < 0 || type > 255 ) {
@@ -710,7 +801,9 @@ namespace mongo {
         }
     }
 
-    JSBool bindata_tostring(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool bindata_tostring(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
         int type = (int)c.getNumber( obj , "type" );
         int len = (int)c.getNumber( obj, "len" );
@@ -722,10 +815,13 @@ namespace mongo {
         base64::encode( ss, (const char *)data, len );
         ss << "\")";
         string ret = ss.str();
-        return *rval = c.toval( ret.c_str() );
+        JS_SET_RVAL(cx, vp, c.toval( ret.c_str() ));
+        return JS_RVAL(cx, vp);
     }
 
-    JSBool bindataBase64(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool bindataBase64(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
         int len = (int)c.getNumber( obj, "len" );
         void *holder = JS_GetPrivate( cx, obj );
@@ -734,10 +830,13 @@ namespace mongo {
         stringstream ss;
         base64::encode( ss, (const char *)data, len );
         string ret = ss.str();
-        return *rval = c.toval( ret.c_str() );
+        JS_SET_RVAL(cx, vp, c.toval( ret.c_str() ));
+        return JS_RVAL(cx, vp);
     }
 
-    JSBool bindataAsHex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool bindataAsHex(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
         int len = (int)c.getNumber( obj, "len" );
         void *holder = JS_GetPrivate( cx, obj );
@@ -750,22 +849,29 @@ namespace mongo {
             ss << v;
         }
         string ret = ss.str();
-        return *rval = c.toval( ret.c_str() );
+        JS_SET_RVAL(cx, vp, c.toval( ret.c_str() ));
+        return JS_RVAL(cx, vp);
     }
 
-    JSBool bindataLength(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool bindataLength(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
         int len = (int)c.getNumber( obj, "len" );
-        return *rval = c.toval((double) len);
+        JS_SET_RVAL(cx, vp, c.toval((double) len));
+        return JS_RVAL(cx, vp);
     }
 
-    JSBool bindataSubtype(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool bindataSubtype(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
         int t = (int)c.getNumber( obj, "type" );
-        return *rval = c.toval((double) t);
+        JS_SET_RVAL(cx, vp, c.toval((double) t));
+        return JS_RVAL(cx, vp);
     }
 
-    void bindata_finalize( JSContext * cx , JSObject * obj ) {
+    void bindata_finalize( JSContext * cx , JSObject * obj ) {        
         Convertor c(cx);
         void *holder = JS_GetPrivate( cx, obj );
         if ( holder ) {
@@ -782,11 +888,11 @@ namespace mongo {
     };
 
     JSFunctionSpec bindata_functions[] = {
-        { "toString" , bindata_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "hex", bindataAsHex, 0, JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "base64", bindataBase64, 0, JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "length", bindataLength, 0, JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "subtype", bindataSubtype, 0, JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
+        { "toString" , bindata_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "hex", bindataAsHex, 0, JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "base64", bindataBase64, 0, JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "length", bindataLength, 0, JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "subtype", bindataSubtype, 0, JSPROP_READONLY | JSPROP_PERMANENT} ,
         { 0 }
     };
 
@@ -796,11 +902,15 @@ namespace mongo {
         return s == "put" || s == "get" || s == "_get" || s == "values" || s == "_data" || s == "constructor" ;
     }
 
-    JSBool map_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    extern JSClass map_class;
+  
+    JSBool map_constructor( JSContext *cx, uintN argc, jsval *vp) {
         if ( argc > 0 ) {
             JS_ReportError( cx , "Map takes no arguments" );
             return JS_FALSE;
         }
+        JSObject *obj = JS_NewObject(cx, &map_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
 
         JSObject * array = JS_NewObject( cx , 0 , 0 , 0 );
         CHECKNEWOBJECT( array, cx, "map_constructor" );
@@ -811,12 +921,12 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool map_prop( JSContext *cx, JSObject *obj, jsval idval, jsval *vp ) {
+    JSBool map_prop( JSContext *cx, JSObject *obj, jsid id, jsval *vp ) {
         Convertor c(cx);
-        if ( specialMapString( c.toString( idval ) ) )
+        if ( specialMapString( c.toString( JSID_TO_STRING(id) ) ) )
             return JS_TRUE;
 
-        log() << "illegal prop access: " << c.toString( idval ) << endl;
+        log() << "illegal prop access: " << c.toString( JSID_TO_STRING(id) ) << endl;
         JS_ReportError( cx , "can't use array access with Map" );
         return JS_FALSE;
     }
@@ -842,13 +952,18 @@ namespace mongo {
         JSCLASS_NO_OPTIONAL_MEMBERS
     };
 
-    JSBool timestamp_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool timestamp_constructor( JSContext *cx, uintN argc, jsval *vp ) {
         smuassert( cx , "Timestamp needs 0 or 2 args" , argc == 0 || argc == 2 );
+    
+        JSObject *obj = JS_NewObject(cx, &timestamp_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
+        jsval *argv = JS_ARGV(cx, vp);
 
         if ( ! JS_InstanceOf( cx , obj , &timestamp_class , 0 ) ) {
             obj = JS_NewObject( cx , &timestamp_class , 0 , 0 );
             CHECKNEWOBJECT( obj, cx, "timestamp_constructor" );
-            *rval = OBJECT_TO_JSVAL( obj );
+            JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL( obj ));
         }
 
         Convertor c( cx );
@@ -872,13 +987,18 @@ namespace mongo {
         JSCLASS_NO_OPTIONAL_MEMBERS
     };
 
-    JSBool numberlong_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    JSBool numberlong_constructor( JSContext *cx, uintN argc, jsval *vp ) {
         smuassert( cx , "NumberLong needs 0 or 1 args" , argc == 0 || argc == 1 );
+    
+        JSObject *obj = JS_NewObject(cx, &numberlong_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
+        jsval *argv = JS_ARGV(cx, vp);
 
         if ( ! JS_InstanceOf( cx , obj , &numberlong_class , 0 ) ) {
             obj = JS_NewObject( cx , &numberlong_class , 0 , 0 );
             CHECKNEWOBJECT( obj, cx, "numberlong_constructor" );
-            *rval = OBJECT_TO_JSVAL( obj );
+            JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL( obj ));
         }
 
         Convertor c( cx );
@@ -906,16 +1026,21 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool numberlong_valueof(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool numberlong_valueof(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
-        return *rval = c.toval( double( c.toNumberLongUnsafe( obj ) ) );
+        JS_SET_RVAL(cx, vp, c.toval( double( c.toNumberLongUnsafe( obj ) ) ));
+        return JS_RVAL(cx, vp);
     }
 
-    JSBool numberlong_tonumber(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
-        return numberlong_valueof( cx, obj, argc, argv, rval );
+    JSBool numberlong_tonumber(JSContext *cx, uintN argc, jsval *vp) {
+        return numberlong_valueof( cx, argc, vp );
     }
 
-    JSBool numberlong_tostring(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
+    JSBool numberlong_tostring(JSContext *cx, uintN argc, jsval *vp) {
+        JSObject *obj = JS_THIS_OBJECT(cx, vp);
+        assert(obj);
         Convertor c(cx);
         stringstream ss;
         long long val = c.toNumberLongUnsafe( obj );
@@ -927,13 +1052,14 @@ namespace mongo {
             ss << "NumberLong(" << val << ")";
 
         string ret = ss.str();
-        return *rval = c.toval( ret.c_str() );
+        JS_SET_RVAL(cx, vp, c.toval( ret.c_str() ));
+        return JS_RVAL(cx, vp);
     }
 
     JSFunctionSpec numberlong_functions[] = {
-        { "valueOf" , numberlong_valueof , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "toNumber" , numberlong_tonumber , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
-        { "toString" , numberlong_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT, 0 } ,
+        { "valueOf" , numberlong_valueof , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "toNumber" , numberlong_tonumber , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
+        { "toString" , numberlong_tostring , 0 , JSPROP_READONLY | JSPROP_PERMANENT} ,
         { 0 }
     };
 
@@ -953,8 +1079,15 @@ namespace mongo {
 
     // dbquery
 
-    JSBool dbquery_constructor( JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval ) {
+    extern JSClass dbquery_class;
+  
+    JSBool dbquery_constructor( JSContext *cx, uintN argc, jsval *vp ) {
+        JSObject *obj = JS_NewObject(cx, &dbquery_class, NULL, NULL);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+    
         smuassert( cx ,  "DDQuery needs at least 4 args" , argc >= 4 );
+    
+        jsval *argv = JS_ARGV(cx, vp);
 
         Convertor c(cx);
         c.setProperty( obj , "_mongo" , argv[0] );
@@ -1004,17 +1137,20 @@ namespace mongo {
         return JS_TRUE;
     }
 
-    JSBool dbquery_resolve( JSContext *cx, JSObject *obj, jsval id, uintN flags, JSObject **objp ) {
+    JSBool dbquery_resolve( JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp ) {
         if ( flags & JSRESOLVE_ASSIGNING )
             return JS_TRUE;
+        
+        jsval arg;
+        assert( JS_IdToValue(cx, id, &arg) );
 
-        if ( ! JSVAL_IS_NUMBER( id ) )
+        if ( ! JSVAL_IS_NUMBER( arg ) )
             return JS_TRUE;
 
         jsval val = JSVAL_VOID;
-        assert( JS_CallFunctionName( cx , obj , "arrayAccess" , 1 , &id , &val ) );
+        assert( JS_CallFunctionName( cx , obj , "arrayAccess" , 1 , &arg, &val ) );
         Convertor c(cx);
-        c.setProperty( obj , c.toString( id ).c_str() , val );
+        c.setProperty( obj , c.toString( arg ).c_str() , val );
         *objp = obj;
         return JS_TRUE;
     }
@@ -1118,11 +1254,13 @@ namespace mongo {
             return true;
         }
 #else
-        if ( JS_InstanceOf( c->_context , o, &js_DateClass , 0 ) ) {
+        {
             jsdouble d = js_DateGetMsecSinceEpoch( c->_context , o );
+            if ( d ) {
             //TODO: make signed
             b.appendDate( name , Date_t((unsigned long long)d) );
             return true;
+            }
         }
 #endif
 
@@ -1153,7 +1291,7 @@ namespace mongo {
 #if defined( SM16 ) || defined( MOZJS ) || defined( XULRUNNER )
         return js_DateGetMsecSinceEpoch( cx , o ) != 0;
 #else
-        return JS_InstanceOf( cx , o, &js_DateClass, 0 );
+        return js_DateGetMsecSinceEpoch( cx , o ) != 0;
 #endif
     }
 
